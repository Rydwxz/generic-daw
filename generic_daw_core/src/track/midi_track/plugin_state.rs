#![expect(dead_code)]

use crate::{DirtyEvent, MidiNote};
use atomig::Atomic;
use clap_host::PluginAudioProcessor;
use std::sync::{Arc, Mutex};

pub const BUFFER_SIZE: usize = 256;

#[derive(Debug)]
pub struct PluginState {
    /// send messages to the plugin
    pub plugin: PluginAudioProcessor,
    /// the combined midi of all clips in the track
    pub global_midi_cache: Vec<MidiNote>,
    /// how the midi was modified since the last buffer refresh
    pub dirty: Arc<Atomic<DirtyEvent>>,
    /// all currently playing notes
    pub started_notes: Vec<MidiNote>,
    /// the last global time that was fetched.
    ///
    /// use this to determine whether the playhead jumped
    pub last_global_time: usize,
    /// a buffer of samples generated by the plugin
    ///
    /// this is refreshed when trying to fetch from it, if `dirty` is marked with an event
    pub running_buffer: [f32; BUFFER_SIZE],
    /// the last index in the buffer that was accessed
    pub last_buffer_index: usize,
}

impl PluginState {
    pub fn create(plugin: PluginAudioProcessor) -> Mutex<Self> {
        Mutex::new(Self {
            plugin,
            global_midi_cache: Vec::new(),
            dirty: Arc::default(),
            started_notes: Vec::new(),
            last_global_time: 0,
            running_buffer: [0.0; BUFFER_SIZE],
            last_buffer_index: BUFFER_SIZE - 1,
        })
    }
}
